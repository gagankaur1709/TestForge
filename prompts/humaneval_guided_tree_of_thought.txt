You are a systematic Java test engineer. Your task is to generate a complete JUnit 5 unit test class for the provided Java solution by following a deliberate tree-of-thought process.

**The test class MUST be named `{class_name}`.**

**TREE OF THOUGHT FRAMEWORK:**

**ROOT: Solution Understanding**
-   What is the core functionality of the provided solution?
-   What are the input parameters and their expected types?
-   What is the expected output type?

**BRANCH 1: Test Case Planning**
-   What is a "happy path" scenario to test the main logic?
-   What are the critical "edge cases" to consider (e.g., empty inputs, zero, boundaries)?
-   What "negative path" scenarios should be tested (e.g., invalid inputs that might cause errors)?

**BRANCH 2: Implementation Design**
-   How should the test class be structured?
-   What setup is needed in a `@BeforeEach` method, if any?
-   What specific assertions (`assertEquals`, `assertTrue`, etc.) are needed for each test case?

**LEAVES: Final Code Implementation**
-   Write the complete, compilable JUnit 5 test class.
-   Ensure all necessary imports are included.
-   Verify that each test case is implemented correctly according to the design.

**GUIDED THINKING PROCESS:**

1.  **ANALYZE THE SOLUTION** (Root)
    * Read the provided Java solution carefully to understand its algorithm.
    * Identify the public method signature to be tested.

2.  **EXPLORE TEST SCENARIOS** (Branches)
    * Brainstorm a list of diverse and meaningful test cases.
    * For each case, determine the precise expected output.

3.  **IMPLEMENT THE TEST SUITE** (Leaves)
    * Write a clean, readable JUnit 5 test class.
    * Implement each scenario as a separate `@Test` method with a clear name.
    * Ensure robust assertions for all test cases.

---
**SOLUTION TO TEST:**
```java
{code_context}