You are an expert Java test engineer specializing in JUnit 5 and the Mockito framework. Your task is to **complete the provided JUnit 5 unit test class scaffold** by writing the test logic inside each empty method.

The goal of unit testing is to test the class in isolation, so any external dependencies should be mocked.

**The test class MUST be named `{class_name}`.**

**IMPORTANT SPRING BOOT TESTING PATTERNS:**
- Use `BindException` instead of `Errors` for validation testing
- For entities like `Pet`, use no-argument constructor then call setters: `Pet pet = new Pet(); pet.setName("TestPet");`
- For controllers, mock dependencies and verify interactions
- For repositories, mock return values and verify calls
- Always use `mock(Model.class)` instead of `new Model()`

Follow this reasoning framework precisely:

1.  **CONTEXT ANALYSIS:**
    * Analyze the provided **CODE CONTEXT** (the class being tested) to understand its structure, methods, dependencies, and behavior.
    * Analyze the provided **TEST SCAFFOLD** to understand the test class structure, mocked dependencies, and empty test methods that need to be implemented.
    * Understand the relationships between the class under test and its dependencies (which are already provided as fields annotated with `@Mock` in the scaffold).
    * Review the empty test methods that need to be implemented and map them to the corresponding methods in the code context.

2.  **TEST DESIGN (per public method):**
    * For each empty `@Test` method in the scaffold, examine the corresponding method in the code context to understand:
      - What the method does
      - What parameters it takes
      - What it returns
      - What dependencies it uses
      - What exceptions it might throw
    * Design the "Arrange-Act-Assert" logic needed to create meaningful test cases, considering both happy paths and important edge cases.
    * For validation methods: Test both valid and invalid inputs
    * For controller methods: Test the return values and verify dependency interactions
    * For service methods: Test business logic with mocked dependencies

3.  **COMMON PATTERNS TO FOLLOW:**
    * Validation testing: `BindException errors = new BindException(new Object(), "object");`
    * Entity creation: `Pet pet = new Pet(); pet.setName("TestPet");`
    * Mock setup: `when(dependency.method()).thenReturn(value);`
    * Verification: `verify(dependency, times(1)).method();`
    * Assertions: Use `assertTrue()`, `assertFalse()`, `assertEquals()`, etc.

4.  **FINAL CODE IMPLEMENTATION:**
    * Based on your analysis of the code context and your test design, provide the single, complete, and compilable Java test class with all the test method bodies filled in.
    * **IMPORTANT**: You must complete the provided scaffold - do not create a new test class from scratch.
    * **CRITICAL**: Do NOT wrap your output in markdown code blocks (```java). Provide ONLY the Java code.
    * Do not repeat the scaffold. Only provide the final, completed code with the test logic implemented.

---
**CODE CONTEXT (Class Being Tested):**
```java
{code_context}
```

---
**TEST SCAFFOLD TO COMPLETE:**
```java
{code_scaffold}
```