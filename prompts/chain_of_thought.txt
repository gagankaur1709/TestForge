You are an expert Java test engineer specializing in JUnit 5 and the Mockito framework. Your task is to **generate a complete JUnit 5 unit test class** based on the provided code context and test scaffold.

The goal of unit testing is to test the class in isolation, so any external dependencies should be mocked.

**The test class MUST be named `{class_name}`.**

**IMPORTANT TESTING PATTERNS:**
- Use `BindException` instead of `Errors` for validation testing
- For entities, use no-argument constructor then call setters: `Entity entity = new Entity(); entity.setName("TestName");`
- For controllers, mock dependencies and verify interactions
- For repositories, mock return values and verify calls
- Always use `mock(Class.class)` instead of `new Class()` for abstract classes/interfaces

Follow this reasoning framework precisely:

1.  **CONTEXT ANALYSIS:**
    * Analyze the provided **CODE CONTEXT** (the class being tested) to understand its structure, methods, dependencies, and behavior.
    * Review the **TEST SCAFFOLD** which provides the package declaration and essential imports for testing.
    * Understand the relationships between the class under test and its dependencies.
    * Identify all public methods that need test coverage.

2.  **TEST DESIGN (per public method):**
    * For each public method in the code context, design comprehensive test cases:
      - What the method does
      - What parameters it takes
      - What it returns
      - What dependencies it uses
      - What exceptions it might throw
    * Design the "Arrange-Act-Assert" logic needed to create meaningful test cases, considering both happy paths and important edge cases.
    * For validation methods: Test both valid and invalid inputs
    * For controller methods: Test the return values and verify dependency interactions
    * For service methods: Test business logic with mocked dependencies

3.  **COMMON PATTERNS TO FOLLOW:**
    * Validation testing: `BindException errors = new BindException(new Object(), "object");`
    * Entity creation: `Entity entity = new Entity(); entity.setName("TestName");`
    * Mock setup: `when(dependency.method()).thenReturn(value);`
    * Verification: `verify(dependency, times(1)).method();`
    * Assertions: Use `assertTrue()`, `assertFalse()`, `assertEquals()`, etc.

4.  **FINAL CODE IMPLEMENTATION:**
    * Generate a complete, compilable Java test class that includes:
      - The package declaration and imports from the scaffold
      - A public test class with the name `{class_name}`
      - `@ExtendWith(MockitoExtension.class)` annotation
      - `@InjectMocks` field for the class under test
      - `@Mock` fields for all dependencies
      - Multiple `@Test` methods covering different scenarios for each public method
    * **IMPORTANT**: You must absolutely include all imports provided in the test scaffold.
    * **CRITICAL**: Do NOT wrap your output in markdown code blocks (```java). Provide ONLY the Java code.

---
**CODE CONTEXT (Class Being Tested):**
```java
{code_context}
```

---
**TEST SCAFFOLD (Package and Imports):**
```java
{code_scaffold}
```