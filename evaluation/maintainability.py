# evaluation/maintainability.py

import subprocess
import os
import xml.etree.ElementTree as ET

def analyze_maintainability(test_file_path: str, pmd_path: str, ruleset_path: str) -> dict:
    """
    Analyzes the maintainability of a generated Java test file using PMD.

    This function will:
    1. Run the PMD static analysis tool on the test file.
    2. Parse the XML report generated by PMD.
    3. Extract key maintainability metrics.

    Args:
        test_file_path: The path to the generated Java test file to analyze.
        pmd_path: The path to the PMD installation directory.
        ruleset_path: The path to the XML ruleset file for PMD.

    Returns:
        A dictionary containing maintainability metrics.
    """
    print(f"Analyzing maintainability for: {test_file_path}")
    
    results = {
        "cyclomatic_complexity": 0,
        "cognitive_complexity": 0,  # Note: PMD doesn't calculate this directly, placeholder
        "coupling_between_objects": 0,
        "test_brittleness_score": 0 # Placeholder for future implementation
    }
    
    report_file = "pmd_report.xml"

    # Construct the command to run PMD
    # On Windows, the command might be 'pmd.bat' instead of 'run.sh pmd'
    pmd_executable = os.path.join(pmd_path, 'bin', 'pmd')
    command = [
        pmd_executable,
        '-d', test_file_path,
        '-f', 'xml',
        '-R', ruleset_path,
        '-r', report_file
    ]

    try:
        # Run PMD as a subprocess
        subprocess.run(command, check=True, capture_output=True, text=True)
        
        # Parse the generated XML report
        if os.path.exists(report_file):
            tree = ET.parse(report_file)
            root = tree.getroot()
            
            # Namespace is often required for parsing PMD reports
            ns = {'pmd': 'http://pmd.sourceforge.net/report/2.0.0'}
            
            # Extract metrics from violations reported by PMD
            # This is an example; you'll need to adjust based on your ruleset
            for violation in root.findall('.//pmd:violation', ns):
                rule = violation.get('rule')
                if rule == 'CyclomaticComplexity':
                    # PMD often reports complexity in the message
                    message = violation.text
                    if message:
                        try:
                            # Example message: "The method 'testMethod' has a Cyclomatic Complexity of 10."
                            complexity = int(message.split(" of ")[-1].replace('.', ''))
                            results['cyclomatic_complexity'] += complexity
                        except (ValueError, IndexError):
                            pass # Handle cases where parsing fails
                
                elif rule == 'CouplingBetweenObjects':
                    message = violation.text
                    if message:
                        try:
                            # Example message: "The class 'TestClass' has a coupling of 5."
                            coupling = int(message.split(" of ")[-1].replace('.', ''))
                            results['coupling_between_objects'] = coupling # Usually one value per class
                        except (ValueError, IndexError):
                            pass

            os.remove(report_file) # Clean up the report file
        
    except subprocess.CalledProcessError as e:
        print(f"PMD analysis failed with exit code {e.returncode}")
        print(f"Stderr: {e.stderr}")
    except Exception as e:
        print(f"An error occurred during maintainability analysis: {e}")

    return results

