# evaluation/maintainability.py

import subprocess
import os
import xml.etree.ElementTree as ET
import re
import jellyfish

def analyze_maintainability(test_file_path: str, pmd_path: str, ruleset_path: str) -> dict:
    """
    Analyzes the maintainability of a generated Java test file using PMD.

    This function will:
    1. Run the PMD static analysis tool on the test file.
    2. Parse the XML report generated by PMD.
    3. Extract key maintainability metrics.

    Args:
        test_file_path: The path to the generated Java test file to analyze.
        pmd_path: The path to the PMD installation directory.
        ruleset_path: The path to the XML ruleset file for PMD.

    Returns:
        A dictionary containing maintainability metrics.
    """
    print(f"Analyzing maintainability for: {test_file_path}")
    
    # Check if PMD path exists
    if not os.path.exists(pmd_path):
        print(f"ERROR: PMD path does not exist: {pmd_path}")
        return results
    
    # Check if ruleset path exists
    if not os.path.exists(ruleset_path):
        print(f"ERROR: Ruleset path does not exist: {ruleset_path}")
        return results
    
    results = {
        "cyclomatic_complexity": 0,
        "cognitive_complexity": 0, 
        "coupling_between_objects": 0,
        "test_brittleness_score": 0 
    }
    
    report_file = os.path.join(os.path.dirname(test_file_path), "pmd_report.xml")

    pmd_executable = os.path.join(pmd_path, 'bin', 'pmd')
    
    # Check if PMD executable exists
    if not os.path.exists(pmd_executable):
        print(f"ERROR: PMD executable does not exist: {pmd_executable}")
        return results
    
    pmd_cmd = [
        pmd_executable, "check",
        "--dir", os.path.dirname(test_file_path),
        "--rulesets", ruleset_path,
        "--format", "xml",
        "--report-file", report_file
    ]

    result = subprocess.run(pmd_cmd, capture_output=True, text=True)
    if os.path.exists(report_file):
        try:
            tree = ET.parse(report_file)
            root = tree.getroot()
            violations = list(root.iter('{http://pmd.sourceforge.net/report/2.0.0}violation'))
            
            for violation in violations:
                rule = violation.get('rule')
                message = violation.text
                
                if rule == 'CyclomaticComplexity' and message:
                    try:
                        match = re.search(r"cyclomatic complexity of (\d+)", message)
                        if match:
                            complexity = int(match.group(1))
                            results['cyclomatic_complexity'] += complexity
                    except Exception as e:
                        pass
                elif rule == 'CouplingBetweenObjects' and message:
                    try:
                        match = re.search(r"of (\d+)", message)
                        if match:
                            coupling = int(match.group(1))
                            results['coupling_between_objects'] = coupling
                    except Exception as e:
                        pass
            
            os.remove(report_file)
        except Exception as e:
            print(f"Error parsing PMD report: {e}")
        
    return results


def calculate_correction_distance(original_code_path: str, fixed_code_path: str) -> float:
    if not os.path.exists(original_code_path) or not os.path.exists(fixed_code_path):
        return -1.0

    with open(original_code_path, 'r', encoding='utf-8') as f:
        original_code = f.read()
    with open(fixed_code_path, 'r', encoding='utf-8') as f:
        fixed_code = f.read()

    distance = jellyfish.levenshtein_distance(original_code, fixed_code)
    max_len = max(len(original_code), len(fixed_code))
    if max_len == 0:
        return 0.0
        
    return distance / max_len
