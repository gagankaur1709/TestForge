import json
import os
import re

def load_scenario(scenario_name):
    """
    Loads a specific scenario's details from the scenarios.json file.

    Args:
        scenario_name (str): The name of the scenario to load.

    Returns:
        dict: A dictionary containing the scenario's description, type,
              relevant files, and a prompt context hint.

    Raises:
        FileNotFoundError: If scenarios.json is not found.
        ValueError: If the specified scenario_name is not found in the JSON.
    """
    # Construct the path to scenarios.json relative to the current script
    scenarios_file_path = os.path.join(os.path.dirname(__file__), 'scenarios.json')
    if not os.path.exists(scenarios_file_path):
        raise FileNotFoundError(f"scenarios.json not found at {scenarios_file_path}")

    with open(scenarios_file_path, 'r') as f:
        scenarios = json.load(f)

    if scenario_name not in scenarios:
        raise ValueError(f"Scenario '{scenario_name}' not found in scenarios.json")

    return scenarios[scenario_name]

def load_code_context(benchmark_path, scenario):
    """
    Loads the code content for the relevant files specified in the scenario.

    Args:
        benchmark_path (str): The root path of the benchmark project (e.g., Spring PetClinic).
        scenario (dict): The dictionary containing scenario details, including 'relevant_files'
                         and 'prompt_context_hint'.

    Returns:
        dict: A dictionary containing:
              - 'files': A dictionary where keys are relative file paths and values are code content.
              - 'prompt_context_hint': A string providing context for LLM prompting.
    """
    code_context = {}
    for relative_path in scenario['relevant_files']:
        full_path = os.path.join(benchmark_path, relative_path)
        if not os.path.exists(full_path):
            print(f"Warning: Relevant file not found: {full_path}. Skipping.")
            continue
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                code_context[relative_path] = f.read()
        except Exception as e:
            print(f"Error reading file {full_path}: {e}")
            continue
    
    # The prompt_context_hint is crucial for guiding the LLM
    return {
        "files": code_context,
        "prompt_context_hint": scenario.get("prompt_context_hint", "")
    }
    """
    Post-processes the generated Java test code to extract the class name
    and rename the file accordingly. This ensures the Java file name matches
    the public class name, which is necessary for compilation.

    Args:
        generated_code (str): The raw Java code generated by the LLM.
        output_dir (str): The directory where the test file should be saved.

    Returns:
        str: The new file name (e.g., "MyGeneratedTest.java").
    """
    class_name = "GeneratedTest" # Default name if no class name is found
    # Regex to find 'public class <ClassName>'
    match = re.search(r'public\s+class\s+(\w+)', generated_code)
    if match:
        class_name = match.group(1)
    
    new_file_name = f"{class_name}.java"
    new_file_path = os.path.join(output_dir, new_file_name)

    with open(new_file_path, 'w', encoding='utf-8') as f:
        f.write(generated_code)

    initial_temp_path = os.path.join(output_dir, "GeneratedTest.java")
    if os.path.exists(initial_temp_path) and new_file_name != "GeneratedTest.java":
        os.remove(initial_temp_path)
    
    return new_file_name


def postprocess_java_test(generated_code: str, target_dir: str) -> str:
    """
    Post-processes the generated Java test code to extract the class name
    and writes the file to the specified target directory.
    """
    class_name = "GeneratedTest"
    match = re.search(r'public\s+class\s+(\w+)', generated_code)
    if match:
        class_name = match.group(1)
    
    new_file_name = f"{class_name}.java"
    new_file_path = os.path.join(target_dir, new_file_name)

    try:
        with open(new_file_path, 'w', encoding='utf-8') as f:
            f.write(generated_code)
        # Removed the print statement here as it's handled in run_experiment.py
    except Exception as e:
        print(f"Error writing generated test to {new_file_path}: {e}")
        # Consider re-raising or handling this error more robustly
        
    return new_file_name